"use server";

import type { Artist, PlaylistTrack, PaginatedResponse, PlaylistSummary, PlaylistsApiResponse, Playlist } from "@/types/spotify";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
// Cache for playlist tracks
const playlistTracksCache = new Map<string, PlaylistTrack[]>();

async function getSpotifyAccessToken(): Promise<string> {
  const headersList = await headers();
  
  // Convert Headers object to plain object format that better-auth expects
  const headersObj: Record<string, string> = {};
  headersList.forEach((value, key) => {
    headersObj[key] = value;
  });
  
  const { accessToken } = await auth.api.getAccessToken({
    body: {
      providerId: "spotify"
    },
    headers: headersObj
  });

  return accessToken;
}

async function fetchAllPlaylistTracks(playlistId: string): Promise<PlaylistTrack[]> {
  const accessToken = await getSpotifyAccessToken();
  if (!accessToken) {
    throw new Error("Failed to get Spotify access token");
  }
  // Check cache first
  const cachedTracks = playlistTracksCache.get(playlistId);
  if (cachedTracks) {
    return cachedTracks;
  }

  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
  const allTracks: PlaylistTrack[] = [];

  while (url) {
    const response = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch playlist tracks');
    }

    const data: PaginatedResponse<PlaylistTrack> = await response.json();
    allTracks.push(...data.items);
    
    // Move to next page or end loop if no more pages
    url = data.next || '';
  }

  // Store in cache
  playlistTracksCache.set(playlistId, allTracks);
  return allTracks;
}

/**
 * Fetches artists from a playlist that match the search query
 */
export async function searchPlaylistArtists(
  playlistId: string,
  query: string,
): Promise<Artist[]> {
  const tracks = await fetchAllPlaylistTracks(playlistId);

  // Get unique artists from all tracks
  const artists = new Map<string, Artist>();
  tracks.forEach(({ track }) => {
    track.artists.forEach((artist) => {
      if (artist.name.toLowerCase().includes(query.toLowerCase())) {
        artists.set(artist.id, artist);
      }
    });
  });

  return Array.from(artists.values());
}

/**
 * Creates a new playlist based on the original playlist, filtered by selected artists
 */
export async function generateFilteredPlaylist(
  originalPlaylistId: string,
  newPlaylistName: string,
  selectedArtistIds: string[],
  userId: string,
): Promise<string> {
  console.log('Fetching tracks from original playlist...', { originalPlaylistId });
  
  // Use cached tracks if available
  const tracks = playlistTracksCache.get(originalPlaylistId) || await fetchAllPlaylistTracks(originalPlaylistId);

  // Filter tracks by selected artists
  console.log('Filtering tracks by selected artists...', { 
    totalTracks: tracks.length,
    selectedArtistIds
  });
  
  const filteredTrackUris = tracks
    .filter(({ track }) =>
      track.artists.some((artist) => selectedArtistIds.includes(artist.id))
    )
    .map(({ track }) => `spotify:track:${track.id}`);

  console.log('Filtered tracks:', {
    originalCount: tracks.length,
    filteredCount: filteredTrackUris.length
  });

  // Create new playlist
  console.log('Creating new playlist...', { newPlaylistName });
  const accessToken = await getSpotifyAccessToken();
  if (!accessToken) {
    throw new Error("Failed to get Spotify access token");
  }
  const createResponse = await fetch(
    `https://api.spotify.com/v1/users/${userId}/playlists`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: newPlaylistName,
        description: 'Generated by Snobify',
        public: false,
      }),
    }
  );

  if (!createResponse.ok) {
    console.error('Failed to create playlist:', await createResponse.text());
    throw new Error('Failed to create new playlist');
  }

  const newPlaylist = await createResponse.json();
  console.log('New playlist created:', { playlistId: newPlaylist.id });

  // Add tracks to new playlist in chunks of 100 (Spotify API limit)
  if (filteredTrackUris.length > 0) {
    console.log('Adding tracks to new playlist...');
    const chunkSize = 100;
    
    for (let i = 0; i < filteredTrackUris.length; i += chunkSize) {
      const chunk = filteredTrackUris.slice(i, i + chunkSize);
      const addTracksResponse = await fetch(
        `https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`,
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            uris: chunk,
          }),
        }
      );

      if (!addTracksResponse.ok) {
        console.error('Failed to add tracks:', await addTracksResponse.text());
        throw new Error('Failed to add tracks to new playlist');
      }
      console.log(`Added tracks ${i + 1} to ${i + chunk.length}`);
    }
    console.log('Successfully added all tracks to playlist');
  }

  // Clear the cache after successful playlist generation
  playlistTracksCache.delete(originalPlaylistId);

  return newPlaylist.id;
}

/**
 * Fetches a single playlist by ID
 */
export async function fetchPlaylist(playlistId: string): Promise<Playlist> {
  const accessToken = await getSpotifyAccessToken();
  if (!accessToken) {
    throw new Error("Failed to get Spotify access token");
  }

  const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}`, {
    headers: { Authorization: `Bearer ${accessToken}` },
  });

  if (!response.ok) throw new Error('Failed to fetch playlist');

  return await response.json();
}

/**
 * Fetches all playlists for the current user
 */
export async function fetchPlaylists(): Promise<PlaylistSummary[]> {
  const accessToken = await getSpotifyAccessToken();
  if (!accessToken) {
    throw new Error("Failed to get Spotify access token");
  }

  const playlists: PlaylistSummary[] = [];
  let url: string | null = 'https://api.spotify.com/v1/me/playlists';

  while (url) {
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${accessToken}` },
    });

    if (!res.ok) throw new Error('Failed to fetch playlists');

    const data: PlaylistsApiResponse = await res.json();
    playlists.push(...data.items);
    url = data.next;
  }

  return playlists;
}

/**
 * Searches for tracks on Spotify
 * Uses Next.js cache for automatic request deduplication and caching
 */
export async function searchTracks(query: string): Promise<any[]> {
  const accessToken = await getSpotifyAccessToken();
  if (!accessToken) {
    throw new Error("Failed to get Spotify access token");
  }

  const response = await fetch(
    `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=5`,
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      // Use Next.js router cache - automatically deduplicates and caches requests
      next: { revalidate: 3600 } // Cache for 1 hour
    }
  );

  if (!response.ok) {
    throw new Error('Failed to search tracks');
  }

  const data = await response.json();
  return data.tracks?.items || [];
} 