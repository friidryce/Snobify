interface Artist {
  id: string;
  name: string;
}

interface Track {
  id: string;
  artists: Artist[];
}

interface PlaylistTrack {
  track: Track;
}

interface PaginatedResponse {
  items: PlaylistTrack[];
  next: string | null;
}

// Cache for playlist tracks
const playlistTracksCache = new Map<string, PlaylistTrack[]>();

async function fetchAllPlaylistTracks(playlistId: string, accessToken: string): Promise<PlaylistTrack[]> {
  // Check cache first
  const cachedTracks = playlistTracksCache.get(playlistId);
  if (cachedTracks) {
    return cachedTracks;
  }

  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
  const allTracks: PlaylistTrack[] = [];

  while (url) {
    const response = await fetch(url, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch playlist tracks');
    }

    const data: PaginatedResponse = await response.json();
    allTracks.push(...data.items);
    
    // Move to next page or end loop if no more pages
    url = data.next || '';
  }

  // Store in cache
  playlistTracksCache.set(playlistId, allTracks);
  return allTracks;
}

/**
 * Fetches artists from a playlist that match the search query
 */
export async function searchPlaylistArtists(
  playlistId: string,
  query: string,
  accessToken: string
): Promise<Artist[]> {
  const tracks = await fetchAllPlaylistTracks(playlistId, accessToken);

  // Get unique artists from all tracks
  const artists = new Map<string, Artist>();
  tracks.forEach(({ track }) => {
    track.artists.forEach((artist) => {
      if (artist.name.toLowerCase().includes(query.toLowerCase())) {
        artists.set(artist.id, artist);
      }
    });
  });

  return Array.from(artists.values());
}

/**
 * Creates a new playlist based on the original playlist, filtered by selected artists
 */
export async function generateFilteredPlaylist(
  originalPlaylistId: string,
  newPlaylistName: string,
  selectedArtistIds: string[],
  userId: string,
  accessToken: string
): Promise<string> {
  console.log('Fetching tracks from original playlist...', { originalPlaylistId });
  
  // Use cached tracks if available
  const tracks = playlistTracksCache.get(originalPlaylistId) || await fetchAllPlaylistTracks(originalPlaylistId, accessToken);

  // Filter tracks by selected artists
  console.log('Filtering tracks by selected artists...', { 
    totalTracks: tracks.length,
    selectedArtistIds
  });
  
  const filteredTrackUris = tracks
    .filter(({ track }) =>
      track.artists.some((artist) => selectedArtistIds.includes(artist.id))
    )
    .map(({ track }) => `spotify:track:${track.id}`);

  console.log('Filtered tracks:', {
    originalCount: tracks.length,
    filteredCount: filteredTrackUris.length
  });

  // Create new playlist
  console.log('Creating new playlist...', { newPlaylistName });
  const createResponse = await fetch(
    `https://api.spotify.com/v1/users/${userId}/playlists`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: newPlaylistName,
        description: 'Generated by Snobify',
        public: false,
      }),
    }
  );

  if (!createResponse.ok) {
    console.error('Failed to create playlist:', await createResponse.text());
    throw new Error('Failed to create new playlist');
  }

  const newPlaylist = await createResponse.json();
  console.log('New playlist created:', { playlistId: newPlaylist.id });

  // Add tracks to new playlist in chunks of 100 (Spotify API limit)
  if (filteredTrackUris.length > 0) {
    console.log('Adding tracks to new playlist...');
    const chunkSize = 100;
    
    for (let i = 0; i < filteredTrackUris.length; i += chunkSize) {
      const chunk = filteredTrackUris.slice(i, i + chunkSize);
      const addTracksResponse = await fetch(
        `https://api.spotify.com/v1/playlists/${newPlaylist.id}/tracks`,
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            uris: chunk,
          }),
        }
      );

      if (!addTracksResponse.ok) {
        console.error('Failed to add tracks:', await addTracksResponse.text());
        throw new Error('Failed to add tracks to new playlist');
      }
      console.log(`Added tracks ${i + 1} to ${i + chunk.length}`);
    }
    console.log('Successfully added all tracks to playlist');
  }

  // Clear the cache after successful playlist generation
  playlistTracksCache.delete(originalPlaylistId);

  return newPlaylist.id;
}

/**
 * Fetches all playlists for the current user
 */
export async function getUserPlaylists(accessToken: string): Promise<{ id: string; name: string }[]> {
  const response = await fetch('https://api.spotify.com/v1/me/playlists', {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });

  if (!response.ok) {
    throw new Error('Failed to fetch user playlists');
  }

  const data = await response.json();
  return data.items.map((item: any) => ({
    id: item.id,
    name: item.name,
  }));
} 